Partie 1 : BubbleSort

Q1 : Voir le programme.
Q2 : Voir le programme.
Q3 : Voir le programme.
Q4 : Voir le programme.
Q5 : En exécutant le programme compilé on obtient:
        -1222 Comparaison pour tab1
        -1225 Comparaison pour tab2
        -1089 Comparaison pour tab3
        -69 Comparaison pour ref

Q6 : Le pire cas du tri à bulle correspond au tab2 (tableau inversé) avec une complexité de o(n²), le meilleur des cas est le ref car le programme s'arrête quand le tableau est trié avec une compléxité de o(n).
     L'algorithme est donc adaptatif car nous n'avons pas le même nombre d'itération en fonction de comment le tableau est trie
Q7 : La complexité spatial et de o(1) sur le programme car on utilise uniquement le tableau initial (voir ligne 70 de fonction.c)
     L'algorithme est stable.

Partie 2 : InsertionSort

Q1 : Voir le programme.
Q2 : En exécutant le programme compilé on obtient:
        -731 Comparaison pour tab1
        -1265 Comparaison pour tab2
        -112 Comparaison pour tab3
        -49 Comparaison pour ref

Q3 : Le pire cas du tri par insertion correspond au tab2 (tableau inversé) avec une complexité de o(n²), le meilleur des cas est le ref car le programme s'arrête quand le tableau est trié avec une compléxité de o(n).
     On remarque que l'algorithme est adaptatif car dans le cas ou le tableau est déjà en partie trié il y a beaucoup moins d'opération à réaliser

Q4 : La complexité spatial et de o(1) sur le programme utilise uniquement le tableau initialement crée  (voir ligne 54 de fonction.c)
     Cet algorithme est stable

Partie 3 : MergeSort

Q1 : si on déclare le tableau de cette manière int* tmp = tab ; on ne crée pas un nouveau tableau mais un autre accès à ce tableau
 int tmp[n]; dans ce cas il est necessaire que n soit connu à la compilation ce qui n'est pas le cas.
Q2 : On utilise la fonction malloc pour faire une allocation dynamique.
Q3 : Voir le programme.
Q4 : Voir le programme.
Q5 : Pour le tri par fusion on a une moins grande disparité dans les différents test que les autres tris.
 Q2 : En exécutant le programme compilé on obtient:
         -254 Comparaison pour tab1
         -286 Comparaison pour tab2
         -152 Comparaison pour tab3
         -68 Comparaison pour ref
     Nous avons également remarqué avant d'avoir optimisé le code, le nombre de comparaison est constant entre les différents tri

Q6 : Sur tout les cas le tri fusion a une complexité de o(n*log(n)) on le remarque avec les observations.
Q7 : La complexité spatial et de o(n) sur le programme car nous crée un nouveau tableau de la taille du premier.

CONCLUSION : L'algorithme MergeSort ce trouve être le plus éfficace pour les tris avec beaucoup de valeur et totalement mélangé. Pour les tris avec peu de valeur les autres programmes ce retrouvent plus efficace.

Bonus : voir le programme 
